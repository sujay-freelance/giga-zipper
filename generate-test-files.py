import argparse
import platform
import subprocess
import os
from pathlib import Path
import time
import psutil
import threading

def generate_file(path, size_gb, fast=False):
    path = Path(path)
    if fast and platform.system() == "Linux":
        try:
            subprocess.run(["fallocate", "-l", f"{size_gb}G", str(path)], check=True)
            print(f"File generated using fallocate at {path}")
            return
        except Exception as e:
            print(f"fallocate failed: {e}, falling back to manual write.")

    block_size = 1024 * 1024  # 1 MB
    blocks = size_gb * 1024  # GB to MB
    with open(path, 'wb') as f:
        for _ in range(blocks):
            f.write(os.urandom(block_size))
    print(f"File generated by manual writing at {path}")

def monitor_resources(process, stop_event, usage):
    while not stop_event.is_set():
        mem = process.memory_info().rss
        usage['peak_memory'] = max(usage['peak_memory'], mem)
        cpu = process.cpu_percent(interval=0.1)
        usage['cpu'].append(cpu)

def zip_folder(input_folder, output_zip):
    input_folder = Path(input_folder).resolve()
    output_zip.parent.mkdir(parents=True, exist_ok=True)
    checksum_path = output_zip.with_suffix(".sha256.txt")
    checksum_path.parent.mkdir(parents=True, exist_ok=True)

    process = psutil.Process(os.getpid())
    usage = {'peak_memory': 0, 'cpu': []}
    stop_event = threading.Event()
    monitor_thread = threading.Thread(target=monitor_resources, args=(process, stop_event, usage))
    monitor_thread.start()

    start_time = time.time()

    with zipfile.ZipFile(output_zip, 'w', compression=zipfile.ZIP_STORED) as zipf:
        for root, _, files in os.walk(input_folder):
            for file in files:
                full_path = Path(root) / file
                rel_path = full_path.relative_to(input_folder)
                if full_path.is_file():
                    zipf.write(full_path, arcname=rel_path)

    stop_event.set()
    monitor_thread.join()

    elapsed = time.time() - start_time
    write_checksums(input_folder, checksum_path)

    print(f"Zipped to: {output_zip}")
    print(f"Checksums written to: {checksum_path}")
    print(f"Time taken to zip: {elapsed:.2f} seconds")
    print(f"Peak memory usage during zip: {usage['peak_memory'] / (1024 * 1024):.2f} MB")
    if usage['cpu']:
        print(f"Average CPU usage during zip: {sum(usage['cpu']) / len(usage['cpu']):.2f}%")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate a large test file.")
    parser.add_argument("output", help="Output file path")
    parser.add_argument("--size-gb", type=int, default=1, help="Size of the file in GB (default: 1GB)")
    parser.add_argument("--fast", action="store_true", help="Use fallocate if available (Linux only)")
    args = parser.parse_args()

    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    generate_file(args.output, args.size_gb, args.fast)
